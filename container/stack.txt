template <class T, class Sequence = deque<T>>
class MyStack
{
public:
	typedef typename Sequence::value_type value_type;
	typedef typename Sequence::size_type size_type;
	typedef typename Sequence::reference reference;
	typedef typename Sequence::const_reference const_reference;
protected:
	Sequence c; //底层容器
public:
	bool empty() const {
		return c.empty();
	}
	size_type size() const {
		return c.size();
	}
	reference top() {
		return c.back();
	}
	const_reference top() const {
		return c.back();
	}
	void push(const value_type &x) {
		c.push_back(x);
	}
	void pop() {
		c.pop_back();
	}
	MyStack() {};
	~MyStack() {};
};

void main(){
MyStack<int, list<int> > mystack;
	mystack.push(1);
	mystack.push(2);
	mystack.push(5);
	mystack.push(7);

	cout << mystack.size() << endl;
	cout << mystack.top() << endl;
}